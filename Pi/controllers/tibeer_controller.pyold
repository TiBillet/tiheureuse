import time
import sys
import threading
from hardware.rfid_reader import RFIDReader
from hardware.valve import Valve
from hardware.flow_meter import FlowMeter
from network.backend_client import BackendClient 
from utils.logger import logger

# Paramètres
CARD_GRACE_PERIOD_S = 1.5  # Temps avant de considérer que la carte est partie
UPDATE_INTERVAL_S = 1.0    # Fréquence d'envoi des infos de débit (1 seconde pour être réactif sur l'écran)

class TibeerController:  # Attention à la casse du nom de classe, assurez-vous qu'elle correspond à votre main.py
    def __init__(self):
        logger.info("Initialisation TiBeer Controller (Mode Session Django Direct)...")
        self.rfid = RFIDReader()
        self.valve = Valve()  
        self.flow_meter = FlowMeter()
        self.client = BackendClient()
        
        self.current_uid = None
        self.last_seen_ts = 0
        self.session_id = None
        self.is_serving = False
        self.session_start_vol = 0.0 
        self.last_update_ts = 0
        self.running = True

    def run(self):
        logger.info("Service TiBeer démarré. En attente de badge...")
        
        try:
            while self.running:
                # 1. Lecture RFID
                uid = self.rfid.read_uid()
                now = time.time()

                if uid:
                    # Carte présente
                    self.last_seen_ts = now
                    
                    if not self.is_serving:
                        # Nouvelle tentative de service
                        logger.info(f"Nouveau badge détecté: {uid}")
                        self._handle_new_session(uid)
                    
                    elif uid == self.current_uid:
                         # Service en cours avec la même carte
                         self._handle_pouring_loop(now)
                         
                else:
                    # Pas de carte
                    if self.is_serving:
                        # Est-ce qu'on a dépassé le temps de tolérance (anti-rebond) ?
                        if (now - self.last_seen_ts) > CARD_GRACE_PERIOD_S:
                            logger.info("Badge retiré. Fin de service.")
                            self._end_session()

                # Petite pause pour ne pas saturer le CPU
                time.sleep(0.1)

        except KeyboardInterrupt:
            logger.info("Arrêt manuel (KeyboardInterrupt).")
        finally:
            self.cleanup()

    def _handle_new_session(self, uid):
        """Demande au serveur Django l'autorisation"""
        auth_response = self.client.authorize(uid)
        
        if auth_response.get("authorized") is True:
            self.current_uid = uid
            self.session_id = auth_response.get("session_id")
            
            # Reset compteurs de volume pour cette session
            self.session_start_vol = self.flow_meter.volume_l() * 1000.0 # Conversion en ml
            
            # Ouvrir Vanne
            self.valve.open()
            self.is_serving = True
            logger.info(f"Autorisation OK. Session {self.session_id}. Vanne ouverte.")
            
            # Informer Django: START
            self.client.send_event("pour_start", self.current_uid, self.session_id)
            self.last_update_ts = time.time()
            
        else:
            logger.warning(f"Badge {uid} refusé: {auth_response.get('error')}")
            # Pause pour éviter de spammer l'API si l'utilisateur laisse sa carte refusée
            time.sleep(2.0) 

    def _handle_pouring_loop(self, now):
        """Boucle pendant que la bière coule"""
        # Calcul du volume servi durant CETTE session
        current_total_vol = self.flow_meter.volume_l() * 1000.0
        served_vol = current_total_vol - self.session_start_vol
        
        # Envoie une update à Django toutes les X secondes
        if (now - self.last_update_ts) > UPDATE_INTERVAL_S:
            logger.debug(f"Update volume: {served_vol:.1f} ml")
            self.client.send_event("pour_update", self.current_uid, self.session_id, served_vol)
            self.last_update_ts = now

    def _end_session(self):
        """Ferme la session proprement"""
        self.valve.close()
        logger.info("Vanne fermée.")
        
        if self.current_uid and self.session_id:
            # Calcul final du volume
            final_total_vol = self.flow_meter.volume_l() * 1000.0
            served_vol = final_total_vol - self.session_start_vol
            
            logger.info(f"Envoi fin de session. Volume total: {served_vol:.1f} ml")
            
            # Informer Django: END
            self.client.send_event("pour_end", self.current_uid, self.session_id, served_vol)

        # Réinitialisation des variables d'état
        self.is_serving = False
        self.current_uid = None
        self.session_id = None

    def cleanup(self):
        """Nettoyage en cas d'arrêt"""
        logger.info("Nettoyage des ressources...")
        try:
            self.valve.close()
            # self.rfid.cleanup() # Décommentez si votre drivers RFID a besoin d'un cleanup
        except Exception as e:
            logger.error(f"Erreur cleanup: {e}")
